# 배열 ( Array )

- 데이터를 나열하고, 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조
- 파이썬에서는 리스트 타입이 배열 기능을 제공함.


## 1. 배열이 왜 필요할까?

- 같은 종류의 데이터를 효율적으로 관리하기 위해 사용
- 순차적으로 저장

### 1) 장점 & 단점
- 빠른 접근 가능 (인덱스로) 
- 추가/삭제가 쉽지 않다.( 인덱스 재정렬을 해주거나, 큰 사이즈의 배열을 새롭게 선언해서 옮겨줘야 함 )
- 미리 최대 길이를 지정해줘야 한다.



## 2. 파이썬과 배열

- 파이썬 리스트 활용 ( 파이썬에선 리스트가 배열 기능을 제공하기 때문 )

```python
# 1차원 배열 : 리스트로 구현시
data = [1,2,3,4,5]
```

```python
# 2차원 배열 : 리스트로 구현시
data = [[1,2,3,4,5],[4,5],[6,7,8,9]]
```


------------------


# 큐 ( Queue )

## 1. 큐 구조

- FIFO (First-In, First-Out)
- ```멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현``` 하기 위해 많이 사용됨
  - 큐의 경우, 장단점 보다는 큐의 활용 예시로 프로세스 스케쥴링 방식을 이해해두는게 좋음.

![](https://www.fun-coding.org/00_Images/queue.png)




## 2. 알아둘 용어

- Enqueue
- Dequeue
- Visualgo(동작 방식 시각화): https://visualgo.net/en/list

## 3. 파이썬  queue 라이브러리를 사용해서 큐 자료 구조 사용하기.

### - 3.1 Queue() 로 큐 만들기
```python
import queue

data_queue = queue.Queue()
```

- Enqueue, Dequeue
```python
data_queue.put("data")

data_queue.get()
```

### - 3.2 LifoQueue() 로 큐 만들기(LIFO)
```python
import queue

data_queue = queue.LifoQueue()
```


### - 3.3 PriorityQueue() 로 큐 만들기 (우선 순위 큐)

```python
import queue

data_queue = queue.PriorityQueue()
```
```
data_queue.put((우선순위, data)) 
```


### - 4. List 로 Queue 구현하기

- Queue 를 구현할때 기본적으로 구현해야 하는 기능은 Enqueue 와 Dequeue 다.

```python

queue_list = list()

def Enqueue(data, list):
  list.append(data)
  
def Dequeue(list):
  
  first_data = list[0]
  del list[0]
  return first_data

```



-----------------------
# 스택 (Stack)

## 1. 스택 구조

- LIFO ( Last-In First-Out )
- 대표적으로 브라우저의 콜스택에서 사용된다.
- 주요 기능
  - push() 
  - pop() 
- Visualgo(동작 방식 시각화): https://visualgo.net/en/list


## 2. 스택 구조와 콜 스택
- 스택은 브라우저의 콜 스택에서 사용됨.


![](http://www.tcpschool.com/lectures/img_c_stackframe_01.png)


## 3. 스택 구조의 장단점
- 장점
  - 구조가 단순하고 구현이 쉽다
  - 저장/읽기 속도가 빠르다
  
- 단점
  - 데이터의 최대 갯수를 미리 정해야 한다.
    - 저장 공간의 낭비가 발생할 수 있다.
    - 파이썬의 경우 재귀 함수는 1000번 까지만 호출이 가능함.
  


## 4. 파이썬 리스트 기능에서 제공하는 기능으로 스택 사용해보기
- 파이썬 list 에서 append (인덱스 맨 뒤에 데이터를 추가) 와 
  pop (맨 뒤에 데이터를 제거) 하는 함수를 기본적으로 제공함.

```python
data_stack = list()

data_stack.append(1)
data_stack.append(2)
# data_stack = [1,2]

data_stack.pop()
# 2
# data_stack = 1
```



----------------------

#링크드 리스트 (Linked List)

## 1. 구조
- 연결 리스트라고도 함.
- 일종의 배열의 단점(크기가 고정되어 있음)을 보완한 자료구조이다.
- 물리적(메모리상)에서는 각 데이터들이 떨어져있지만, 개념적으로 연결 되어있는 형태이다.
- 노드(Node) : 데이터 저장 단위(데이터값, 포인터) 로 구성
- 포인터(pointer) : 각 노드 안에서 다음이나 이전 노드와의 연결 정보를 가지고 있는 공간(주소 값)

![](https://www.fun-coding.org/00_Images/linkedlist.png)


## 2. 간단한 링크드 리스트 예
```python
class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
```
- Node와 Node 연결하기 (포인터 활용)

```python
node1 = Node(1)
node2 = Node(2)
node1.next = node2
head = node1
```

- 링크드 리스트로 데이터 추가하기

```python
class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next

def add(data):
    node = head
    while node.next:
        node = node.next
    node.next = Node(data) 
```
```python
node1 = Node(1)
head = node1
for index in range(2, 10):
    add(index)
```

- 링크드 리스트 데이터 출력하기(검색하기)

```python
node = head
while node.next:
    print(node.data)
    node = node.next
print (node.data)
```



## 3. 링크드 리스트 장, 단점

장점 - 배열 처럼 미리 크기를 정해 놓을 필요가 없기 때문에, 동적이다.
    
단점 - 배열은 인덱스로 임의 접근이 가능, but , 링크드 리스트는 앞에서 부터 순차적으로 찾아야 하기 때문에, 접근 속도가 느리다.
    - Node 에 Value 뿐만 아니라 Pointer 도 저장하기 때문에, 배열에 비해 저장공간 효율이 좋지 않다.
    - 중간 데이터 삭제시, 앞뒤 데이터의 연결을 해줘야 하는 부가적인 작업이 필요하다.


## 4. 링크드 리스트에서 구현해야 할 기능1 (중간에 데이터 추가하기)

![](https://www.fun-coding.org/00_Images/linkedlistadd.png)


```python
node = head
while node.next:
    print(node.data)
    node = node.next
print (node.data)
```
```python
node3 = Node(1.5)

node = head
search = True
while search:
    if node.data == 1:
        search = False
    else:
        node = node.next

node_next = node.next
node.next = node3
node3.next = node_next
```



## 파이썬으로 링크드 리스트 구현하기

```python
class Node:
    def __init__(self, data, next=None):  
        self.data = data
        self.next = next

class NodeMgmt:
    def __init__(self, data):
      self.head = Node(data)

    
  
    def add(self, data):
      if self.head == '':
        self.head = Node(data)
      else:
        node = self.head
        while node.next:
          node = node.next
        node.next = Node(data)

def desc(self):
    node = self.head
    while node:
      print(node.data)
      node = node.next

```

```python
linkedlist1 = NodeMgmt(0)
linkedlist1.desc()
### 0

for data in range(1,10):
    linkedlist1.add(data)

linkedlist1.desc()

###0
###1
###2
###....
```


#### 링크드 리스트 삭제 기능 구현

링크드 리스트에서 삭제 되는 Case 는 총 세 가지이다.

1. head 삭제
2. rear 삭제
3. 중간 데이터 삭제


```python
def delete(self, data):
     
     # 방어코드
    if self.head == '',
        print("해당 노드 값이 없습니다.")
        return
        
    
     # head 삭제 시
     if self.head.data == 'data':
         temp = self.head
         self.head = self.head.next
         del temp
     else:
     
     # rear 및 중간 데이터 삭제 시     
         node = self.head
         while node.next:
             if node.next.data == data:
                 temp = node.next
                 node.next = node.next.next
                 del temp
        
```




## 다양한 링크드 리스트 종류


- 더블 링크드 리스트(Doubly linked list)
  - 기본적인 링크드 리스트의 단점 중 하나로, 
    데이터를 탐색 할 때, 맨 앞에서 부터 탐색해야 한다는 점이 있다.
    이를 보완하는 데이터 구조로, 더블 링크드 리스트가 있다.
  - 이중 연결 리스트라고도 한다.
  - 양방향으로 연결되어 있어서, 노드 탐색이 양쪽으로 모두 가능하다.


![](https://www.fun-coding.org/00_Images/doublelinkedlist.png)


```python
class Node:

    def __init__(self, data, prev=None, next=None):
        self.prev = prev
        self.data = data
        self.next = next


class NodeMgmt:
    
    def __init__(self, data):
        self.head = Node(data)
        self.tail = self.head
        
    def insert(self, data):
      if self.head == None:
        
        self.head = Node(data)
        self.tail = self.head
        
      else:
        node = self.head
        while node.next:
          node = node.next
        new = Node(data)
        new.prev = node
        self.tail = new
        
      def desc(self):
        node = self.head
        while node:
          print(node.data)
          node = node.next


```


